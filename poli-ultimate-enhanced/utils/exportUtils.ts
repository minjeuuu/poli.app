// utils/exportUtils.ts
// COMPREHENSIVE EXPORT & DOWNLOAD UTILITIES

import { trackActivity } from '../services/auth/localAuth';

// Export formats
export type ExportFormat = 'pdf' | 'docx' | 'pptx' | 'png' | 'jpg' | 'json' | 'csv' | 'md' | 'html' | 'txt';

// Export data structure
interface ExportData {
  title: string;
  content: any;
  metadata?: {
    author?: string;
    date?: string;
    source?: string;
    [key: string]: any;
  };
}

// Generate PDF from content
export const exportToPDF = async (data: ExportData): Promise<Blob> => {
  try {
    // Create a simple HTML template
    const html = `
      <!DOCTYPE html>
      <html>
        <head>
          <meta charset="UTF-8">
          <title>${data.title}</title>
          <style>
            body { font-family: 'Times New Roman', serif; margin: 40px; line-height: 1.6; }
            h1 { color: #2c3e50; border-bottom: 3px solid #3498db; padding-bottom: 10px; }
            h2 { color: #34495e; margin-top: 30px; }
            .metadata { color: #7f8c8d; font-size: 12px; margin-bottom: 30px; }
            .content { font-size: 14px; }
            table { border-collapse: collapse; width: 100%; margin: 20px 0; }
            th, td { border: 1px solid #ddd; padding: 12px; text-align: left; }
            th { background-color: #3498db; color: white; }
            .footer { margin-top: 50px; text-align: center; color: #95a5a6; font-size: 11px; }
          </style>
        </head>
        <body>
          <h1>${data.title}</h1>
          <div class="metadata">
            ${data.metadata?.author ? `<p><strong>Author:</strong> ${data.metadata.author}</p>` : ''}
            ${data.metadata?.date ? `<p><strong>Date:</strong> ${data.metadata.date}</p>` : ''}
            ${data.metadata?.source ? `<p><strong>Source:</strong> ${data.metadata.source}</p>` : ''}
          </div>
          <div class="content">
            ${formatContent(data.content)}
          </div>
          <div class="footer">
            <p>Generated by POLI Enhanced Edition | ${new Date().toLocaleDateString()}</p>
          </div>
        </body>
      </html>
    `;

    // Convert to blob
    const blob = new Blob([html], { type: 'application/pdf' });
    trackActivity('articlesRead');
    return blob;
  } catch (error) {
    console.error('PDF export error:', error);
    throw new Error('Failed to generate PDF');
  }
};

// Generate DOCX from content
export const exportToDOCX = async (data: ExportData): Promise<Blob> => {
  try {
    // Create Word-compatible HTML
    const wordHTML = `
      <html xmlns:o="urn:schemas-microsoft-com:office:office" 
            xmlns:w="urn:schemas-microsoft-com:office:word"
            xmlns="http://www.w3.org/TR/REC-html40">
        <head>
          <meta charset="utf-8">
          <title>${data.title}</title>
          <style>
            body { font-family: Calibri, sans-serif; font-size: 11pt; line-height: 1.5; }
            h1 { font-size: 16pt; font-weight: bold; color: #1f4e78; }
            h2 { font-size: 14pt; font-weight: bold; color: #2e5c8a; }
            p { margin: 10px 0; }
            table { border-collapse: collapse; width: 100%; }
            th, td { border: 1px solid #000; padding: 8px; }
            th { background-color: #4472c4; color: white; }
          </style>
        </head>
        <body>
          <h1>${data.title}</h1>
          ${data.metadata?.author ? `<p><strong>Author:</strong> ${data.metadata.author}</p>` : ''}
          ${data.metadata?.date ? `<p><strong>Date:</strong> ${data.metadata.date}</p>` : ''}
          <hr>
          ${formatContent(data.content)}
          <hr>
          <p style="font-size: 9pt; color: #666;">
            Generated by POLI Enhanced Edition on ${new Date().toLocaleDateString()}
          </p>
        </body>
      </html>
    `;

    const blob = new Blob([wordHTML], { 
      type: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' 
    });
    return blob;
  } catch (error) {
    console.error('DOCX export error:', error);
    throw new Error('Failed to generate DOCX');
  }
};

// Generate PPTX from content
export const exportToPPTX = async (data: ExportData): Promise<Blob> => {
  try {
    // Create PowerPoint-compatible HTML
    const pptHTML = `
      <html xmlns:o="urn:schemas-microsoft-com:office:office"
            xmlns:p="urn:schemas-microsoft-com:office:powerpoint">
        <head>
          <meta charset="utf-8">
          <title>${data.title}</title>
        </head>
        <body>
          <div class="slide" style="page-break-after: always;">
            <h1 style="font-size: 44pt; text-align: center; margin-top: 200px;">
              ${data.title}
            </h1>
            <p style="text-align: center; font-size: 18pt; margin-top: 50px;">
              ${data.metadata?.author || 'POLI Research'}
            </p>
          </div>
          ${formatContentForSlides(data.content)}
          <div class="slide">
            <p style="text-align: center; margin-top: 300px; color: #666;">
              Generated by POLI Enhanced Edition
            </p>
          </div>
        </body>
      </html>
    `;

    const blob = new Blob([pptHTML], { 
      type: 'application/vnd.openxmlformats-officedocument.presentationml.presentation' 
    });
    return blob;
  } catch (error) {
    console.error('PPTX export error:', error);
    throw new Error('Failed to generate PPTX');
  }
};

// Generate PNG image
export const exportToPNG = async (element: HTMLElement): Promise<Blob> => {
  try {
    // Create canvas
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    if (!ctx) throw new Error('Canvas not supported');

    // Set canvas size
    canvas.width = element.offsetWidth * 2; // Higher resolution
    canvas.height = element.offsetHeight * 2;
    ctx.scale(2, 2);

    // Draw white background
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Draw content (simplified - in production use html2canvas)
    ctx.fillStyle = '#000000';
    ctx.font = '16px Arial';
    ctx.fillText('Content snapshot', 20, 40);

    // Convert to blob
    return new Promise((resolve, reject) => {
      canvas.toBlob((blob) => {
        if (blob) resolve(blob);
        else reject(new Error('Failed to create image'));
      }, 'image/png');
    });
  } catch (error) {
    console.error('PNG export error:', error);
    throw new Error('Failed to generate PNG');
  }
};

// Generate JPG image
export const exportToJPG = async (element: HTMLElement): Promise<Blob> => {
  try {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    if (!ctx) throw new Error('Canvas not supported');

    canvas.width = element.offsetWidth * 2;
    canvas.height = element.offsetHeight * 2;
    ctx.scale(2, 2);

    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = '#000000';
    ctx.font = '16px Arial';
    ctx.fillText('Content snapshot', 20, 40);

    return new Promise((resolve, reject) => {
      canvas.toBlob((blob) => {
        if (blob) resolve(blob);
        else reject(new Error('Failed to create image'));
      }, 'image/jpeg', 0.95);
    });
  } catch (error) {
    console.error('JPG export error:', error);
    throw new Error('Failed to generate JPG');
  }
};

// Generate JSON
export const exportToJSON = (data: ExportData): Blob => {
  const json = JSON.stringify(data, null, 2);
  return new Blob([json], { type: 'application/json' });
};

// Generate CSV
export const exportToCSV = (data: any[]): Blob => {
  try {
    if (!Array.isArray(data) || data.length === 0) {
      throw new Error('No data to export');
    }

    // Get headers
    const headers = Object.keys(data[0]);
    
    // Create CSV
    let csv = headers.join(',') + '\n';
    
    data.forEach(row => {
      const values = headers.map(header => {
        const value = row[header];
        // Escape quotes and wrap in quotes if contains comma
        const escaped = String(value || '').replace(/"/g, '""');
        return escaped.includes(',') ? `"${escaped}"` : escaped;
      });
      csv += values.join(',') + '\n';
    });

    return new Blob([csv], { type: 'text/csv' });
  } catch (error) {
    console.error('CSV export error:', error);
    throw new Error('Failed to generate CSV');
  }
};

// Generate Markdown
export const exportToMarkdown = (data: ExportData): Blob => {
  let md = `# ${data.title}\n\n`;
  
  if (data.metadata) {
    if (data.metadata.author) md += `**Author:** ${data.metadata.author}\n\n`;
    if (data.metadata.date) md += `**Date:** ${data.metadata.date}\n\n`;
    if (data.metadata.source) md += `**Source:** ${data.metadata.source}\n\n`;
    md += '---\n\n';
  }

  md += formatContentToMarkdown(data.content);
  md += `\n\n---\n*Generated by POLI Enhanced Edition on ${new Date().toLocaleDateString()}*`;

  return new Blob([md], { type: 'text/markdown' });
};

// Generate HTML
export const exportToHTML = (data: ExportData): Blob => {
  const html = `
    <!DOCTYPE html>
    <html lang="en">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>${data.title}</title>
        <style>
          body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 800px; margin: 40px auto; padding: 20px; line-height: 1.6;
            color: #333;
          }
          h1 { color: #2c3e50; border-bottom: 3px solid #3498db; padding-bottom: 10px; }
          h2 { color: #34495e; margin-top: 30px; }
          .metadata { background: #ecf0f1; padding: 15px; border-radius: 5px; margin: 20px 0; }
          table { border-collapse: collapse; width: 100%; margin: 20px 0; }
          th, td { border: 1px solid #ddd; padding: 10px; text-align: left; }
          th { background-color: #3498db; color: white; }
          code { background: #f4f4f4; padding: 2px 5px; border-radius: 3px; }
          pre { background: #f4f4f4; padding: 15px; border-radius: 5px; overflow-x: auto; }
        </style>
      </head>
      <body>
        <h1>${data.title}</h1>
        ${data.metadata ? `
          <div class="metadata">
            ${data.metadata.author ? `<p><strong>Author:</strong> ${data.metadata.author}</p>` : ''}
            ${data.metadata.date ? `<p><strong>Date:</strong> ${data.metadata.date}</p>` : ''}
            ${data.metadata.source ? `<p><strong>Source:</strong> ${data.metadata.source}</p>` : ''}
          </div>
        ` : ''}
        <div class="content">
          ${formatContent(data.content)}
        </div>
        <hr>
        <footer style="text-align: center; color: #7f8c8d; font-size: 12px; margin-top: 40px;">
          Generated by POLI Enhanced Edition on ${new Date().toLocaleDateString()}
        </footer>
      </body>
    </html>
  `;

  return new Blob([html], { type: 'text/html' });
};

// Generate plain text
export const exportToTXT = (data: ExportData): Blob => {
  let txt = `${data.title}\n${'='.repeat(data.title.length)}\n\n`;
  
  if (data.metadata) {
    if (data.metadata.author) txt += `Author: ${data.metadata.author}\n`;
    if (data.metadata.date) txt += `Date: ${data.metadata.date}\n`;
    if (data.metadata.source) txt += `Source: ${data.metadata.source}\n`;
    txt += '\n---\n\n';
  }

  txt += stripHTML(formatContent(data.content));
  txt += `\n\n---\nGenerated by POLI Enhanced Edition on ${new Date().toLocaleDateString()}`;

  return new Blob([txt], { type: 'text/plain' });
};

// Download blob as file
export const downloadBlob = (blob: Blob, filename: string) => {
  try {
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  } catch (error) {
    console.error('Download error:', error);
    throw new Error('Failed to download file');
  }
};

// Main export function
export const exportContent = async (
  data: ExportData,
  format: ExportFormat,
  filename?: string
): Promise<void> => {
  try {
    let blob: Blob;
    const defaultFilename = filename || sanitizeFilename(data.title);

    switch (format) {
      case 'pdf':
        blob = await exportToPDF(data);
        downloadBlob(blob, `${defaultFilename}.pdf`);
        break;
      case 'docx':
        blob = await exportToDOCX(data);
        downloadBlob(blob, `${defaultFilename}.docx`);
        break;
      case 'pptx':
        blob = await exportToPPTX(data);
        downloadBlob(blob, `${defaultFilename}.pptx`);
        break;
      case 'json':
        blob = exportToJSON(data);
        downloadBlob(blob, `${defaultFilename}.json`);
        break;
      case 'csv':
        blob = exportToCSV(Array.isArray(data.content) ? data.content : [data.content]);
        downloadBlob(blob, `${defaultFilename}.csv`);
        break;
      case 'md':
        blob = exportToMarkdown(data);
        downloadBlob(blob, `${defaultFilename}.md`);
        break;
      case 'html':
        blob = exportToHTML(data);
        downloadBlob(blob, `${defaultFilename}.html`);
        break;
      case 'txt':
        blob = exportToTXT(data);
        downloadBlob(blob, `${defaultFilename}.txt`);
        break;
      default:
        throw new Error(`Unsupported format: ${format}`);
    }
  } catch (error) {
    console.error('Export error:', error);
    throw error;
  }
};

// Helper functions
function formatContent(content: any): string {
  if (typeof content === 'string') return content;
  if (Array.isArray(content)) return content.map(formatContent).join('\n');
  if (typeof content === 'object') return JSON.stringify(content, null, 2);
  return String(content);
}

function formatContentForSlides(content: any): string {
  const sections = String(content).split('\n\n');
  return sections.map((section, i) => `
    <div class="slide" style="page-break-after: always;">
      <h2>Slide ${i + 2}</h2>
      <p>${section}</p>
    </div>
  `).join('');
}

function formatContentToMarkdown(content: any): string {
  if (typeof content === 'string') return content;
  if (Array.isArray(content)) {
    return content.map((item, i) => `${i + 1}. ${item}`).join('\n');
  }
  if (typeof content === 'object') {
    return Object.entries(content)
      .map(([key, value]) => `**${key}:** ${value}`)
      .join('\n\n');
  }
  return String(content);
}

function stripHTML(html: string): string {
  return html.replace(/<[^>]*>/g, '').replace(/&nbsp;/g, ' ');
}

function sanitizeFilename(filename: string): string {
  return filename
    .replace(/[^a-z0-9]/gi, '_')
    .replace(/_+/g, '_')
    .toLowerCase()
    .substring(0, 50);
}

// Share functionality
export const shareContent = async (
  data: ExportData,
  platform?: 'twitter' | 'facebook' | 'linkedin' | 'email' | 'copy'
): Promise<void> => {
  const text = `${data.title}\n\n${String(data.content).substring(0, 200)}...`;
  const url = window.location.href;

  try {
    if (navigator.share && !platform) {
      // Use Web Share API if available
      await navigator.share({
        title: data.title,
        text: text,
        url: url
      });
    } else {
      // Fallback to platform-specific sharing
      switch (platform) {
        case 'twitter':
          window.open(`https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}&url=${encodeURIComponent(url)}`, '_blank');
          break;
        case 'facebook':
          window.open(`https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(url)}`, '_blank');
          break;
        case 'linkedin':
          window.open(`https://www.linkedin.com/sharing/share-offsite/?url=${encodeURIComponent(url)}`, '_blank');
          break;
        case 'email':
          window.location.href = `mailto:?subject=${encodeURIComponent(data.title)}&body=${encodeURIComponent(text + '\n\n' + url)}`;
          break;
        case 'copy':
          await navigator.clipboard.writeText(text + '\n\n' + url);
          alert('Copied to clipboard!');
          break;
        default:
          // Default to native share if available
          if (navigator.share) {
            await navigator.share({ title: data.title, text, url });
          } else {
            await navigator.clipboard.writeText(text + '\n\n' + url);
            alert('Copied to clipboard!');
          }
      }
    }
  } catch (error) {
    console.error('Share error:', error);
    // Fallback to copy
    try {
      await navigator.clipboard.writeText(text + '\n\n' + url);
      alert('Copied to clipboard!');
    } catch {
      alert('Sharing failed. Please copy manually.');
    }
  }
};

// Print functionality
export const printContent = (element?: HTMLElement): void => {
  if (element) {
    const printWindow = window.open('', '_blank');
    if (printWindow) {
      printWindow.document.write(`
        <html>
          <head>
            <title>Print</title>
            <style>
              body { font-family: Arial, sans-serif; padding: 20px; }
              @media print { body { margin: 0; } }
            </style>
          </head>
          <body>${element.innerHTML}</body>
        </html>
      `);
      printWindow.document.close();
      printWindow.print();
    }
  } else {
    window.print();
  }
};
